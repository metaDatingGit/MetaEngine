/* AS3	Das hier ist die Klasse für die Berechnung der Finalen Playlist */package {		import ProjectObject;	import Utils;		public class ProjectCalc {						public function ProjectCalc (){					}		//--------------------------------------//  PRIVATE VARIABLES//--------------------------------------		private var randNum:int;		private var tempList:Array;		private var playList:Array;		private var metaList:Array;		private var videoObjects: Array;				//--------------------------------------//  PUBLIC METHODS//--------------------------------------				public function calculateClips(xml:XMLList):Array 		{						trace("calc project_name");						//Initialisierung aller nötigen Arrays zum sortieren der Clips			tempList = new Array();			playList = new Array();			metaList = new Array();			videoObjects = new Array();						//FILTERING			for (var i:int = 0; i < xml.length(); i++)			{				//statte jedes "videoobject" in der XML mit den nötigen Attributen aus (diese müssen mit den Attributen in der ProjectObject übereinstimmen)				videoObjects[i] = new ProjectObject (i,													  xml[i].clipname.text(),													  xml[i].pro_contra.text(),													  xml[i].reaction_action.text(),													  xml[i].male_female.text(),													  xml[i].strategy.text(),													  xml[i].intensity.text(),													  xml[i].shot.text(),													  xml[i].clip_pos.text(),													  xml[i].family.text(),													  xml[i].religion.text(),													  xml[i].emotion.text(),													  xml[i].society.text(),													  xml[i].routine.text(),													  xml[i].spare_time.text(),													  xml[i].safety.text(),													  xml[i].freedom.text(),													  xml[i].loyalty_sex.text(),													  xml[i].emotional_reaction.text(),													  xml[i].flowing_reaction.text(),													  xml[i].joker.text()												 		);												//Utils.allFilesNames.push(videoObjects[i].getClipName);								//COARSE FILTERING				/*				if(videoObjects[i].getClipName == "1.mov") tempList.push(videoObjects[i]);				if(videoObjects[i].getClipName == "2.mov") tempList.push(videoObjects[i]);				if(videoObjects[i].getClipName == "3.mov") tempList.push(videoObjects[i]);				if(videoObjects[i].getClipName == "4.mov") tempList.push(videoObjects[i]);				if(videoObjects[i].getClipName == "5.mov") tempList.push(videoObjects[i]);				*/								tempList.push(videoObjects[i]); //hier landen ALLE objekte - kann gelöscht werden falls filterung ausreichend			}									//ASSEMBLE PLAYLIST						//testfunktion um die erfolgreiche implementierung der xml zu testen (kann gelöscht werden)			for(var i:int = 0; i < 10; i++)			{				playList.push(tempList[i].getClipName);				metaList.push(tempList[i]);			}									trace(playList);			return playList; //übergibt die fertige playlist an den Player		}		//FINE FILTERING//--------------------------------------//  PRIVATE METHODS//--------------------------------------				private function intro():void		{			/*			*			*/		}				//--------------------------------------//--------------------------------------//  PUBLIC METHODS / GETTERS / SETTERS//--------------------------------------		public function get getMetaList():Array		{			return metaList;		}	//--------------------------------------		public function get getAllClipNames():Array		{			var returnArr:Array = new Array();						if(videoObjects != null)				for(var i:int = 0; i < videoObjects.length; i++)				{					returnArr.push(videoObjects[i].getClipName);					//trace("clipName: " + videoObjects[i].getClipName);				}			else				trace("ERROR: To call getAllClipNames you have to call calculateClips first");						return returnArr;		}//--------------------------------------				//pusht ein zufälliges objekt aus einem array in ein anderes array		public function pushRandObject(theDestinationArr:Array, theSourceArr:Array):void		{			try			{				//trace("push / länge des source array: " + theSourceArr.length);				if(theSourceArr.length != 0)				{					randNum = Utils.randRound(theSourceArr.length);					theDestinationArr.push(theSourceArr[randNum]);					//clipToRemoveStr = theSourceArr[randNum]/*.getClipName*/;				}				else{trace("------------------------no elements in push");}			}			catch(error:Error)			{				trace("--------------------error in pushRandObject: ");			}		}//--------------------------------------				//pusht einen zufälligen CLIPNAMEN von einem array in ein anderes (in der regel die playlist)		public function pushRandName(theDestinationArr:Array, theSourceArr:Array):void		{			randNum = Utils.randRound(theSourceArr.length);			theDestinationArr.push(theSourceArr[randNum].getClipName);			//clipToRemoveStr = theSourceArr[randNum]/*.getClipName*/;		}		//--------------------------------------				//pusht alle clipnamen in ein anderes array		public function pushClipNames(theDestinationArr:Array, theSourceArr:Array):void		{			//trace("SourceArr: " + theSourceArr.length);			if(theSourceArr.length != 0)			{				for( var i:int = 0; i < theSourceArr.length; i++ )				{					//trace("clipName: " + theSourceArr[i].getClipName);					theDestinationArr.push(theSourceArr[i].getClipName);				}			}			else				trace("ERROR: in pushClipName function: no Element in theSourceArr");		}//--------------------------------------				//pusht alle OBJEKTE in ein anderes array		public function pushClipName(theDestinationArr:Array, theSourceArr:Array):void		{			//trace("SourceArr: " + theSourceArr.length);			if(theSourceArr.length != 0)			{				for( var i:int = 0; i < theSourceArr.length; i++ )				{					//trace("clipName: " + theSourceArr[i].getClipName);					theDestinationArr.push(theSourceArr[i]);				}			}			else				trace("ERROR: in pushClipName function: no Element in theSourceArr");		}//--------------------------------------	}}